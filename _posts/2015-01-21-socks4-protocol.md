---
title: SOCKS: 用于穿透防火墙的TCP代理协议 (译)
---



原文: <http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol>

Ying-Da Lee
yingda@best.com or yingda@esd.sgi.com

SOCKS 最初由 David Koblas 开发, 随后由 Ying-Da Lee 修改并扩展至第 4 版. 本协议在防火墙主机上中继 TCP 会话, 使用户程序可以穿透防火墙透明访问外网. 由于本协议是独立的应用层协议, 因此可以并已经使用在了众多不同的服务中, 如 telnet, ftp, finger, whois, gopher, WWW等等. 访问控制可应用在每个 TCP 会话 的开始阶段, 此后服务器仅中继客户端与应用服务器间的数据, 达到最小处理开销. SOCKS 不需要获知其中继的应用协议, 因此也同样适用于各类加密应用.

协议定义了两种操作: CONNECT 和 BIND.


1) CONNECT
----------

客户端需要与应用服务器建立连接时, 首先连接至 SOCKS 服务器并发送一个 CONNECT 请求. 客户端将目的主机的 IP 地址, 端口号和用户ID置于请求包中, 包格式如下:

               +----+----+----+----+----+----+----+----+----+----+....+----+
               | VN | CD | DSTPORT |       DSTIP       | USERID       |NULL|
               +----+----+----+----+----+----+----+----+----+----+....+----+
# of bytes:       1    1      2              4           variable       1

VN 代表 SOCKS 协议版本, 应为 4. CD 代表 SOCKS 命令码, 连接请求应为 1. NULL 为 1 字节全零位.

SOCKS 服务器根据源 IP 地址, 目的 IP 地址, 目的端口号, 用户 ID 以及从 IDENT 协议获取的信息 (参照 RFC 1413) 间的任意组合, 判断请求是否通过. 如果请求获得通过, SOCKS 服务器将建立一个与目标主机指定端口号的连接. 当连接已建立, 或请求被拒绝以及其他原因操作失败时, SOCKS 服务器将向客户端发送一个中继包.

               +----+----+----+----+----+----+----+----+
               | VN | CD | DSTPORT |       DSTIP       |
               +----+----+----+----+----+----+----+----+
# of bytes:       1    1      2              4

VN 代表回复码版本, 应为 0. CD 代表结果码, 有以下几种取值:

-   90: 请求通过
-   91: 请求被拒或失败
-   92: 请求被拒, 由于 SOCKS 服务器无法连接到客户端的 identd
-   93: 请求被拒, 由于客户端程序与 identd 报告的用户 ID 不匹配

其余字段将被忽略.

SOCKS 服务器通知客户端请求被拒或失败后立刻断开连接. 若请求获得通过, SOCKS 服务器立即准备为双方中继数据. 这使得客户端可以在自己的连接上进行 I/O 操作, 就如同直接连接到应用服务器一样.


2) BIND
-------

当客户端希望为应用服务器的入站连接做准备时, 连接到 SOCKS 服务器并发送一个 BIND 请求. 前提是客户端已通过 CONNECT 操作与应用服务器建立了主连接. 通常情况下, 这是一个操作序列的一部分.

-   bind(): 获得一个 socket
-   getsockname(): 获取 socket 的 IP 地址和端口号
-   listen(): 准备接收应用服务器的连接请求
-   使用主连接告知应用服务器其需要连接的 IP 地址和端口号
-   accept(): 接受应用服务器的连接

SOCKS BIND 操作的目的在于支持这一操作系列, 但该 socket 是用在 SOCKS 服务器上而不是客户端上.

客户端将应用服务器的 IP 地址, 主连接端口号和用户 ID 置于 BIND 请求包中.

               +----+----+----+----+----+----+----+----+----+----+....+----+
               | VN | CD | DSTPORT |       DSTIP       | USERID       |NULL|
               +----+----+----+----+----+----+----+----+----+----+....+----+
# of bytes:       1    1      2              4           variable       1

VN 代表 SOCKS 协议版本, 同样为 4. CD 为 2 代表 BIND 命令.

SOCKS 服务器使用客户端信息决定请求是否通过. 其发往客户端的回复包与 CONNECT 请求的回复包格式相同, 如,

               +----+----+----+----+----+----+----+----+
               | VN | CD | DSTPORT |       DSTIP       |
               +----+----+----+----+----+----+----+----+
# of bytes:       1    1      2              4

VN 代表回复码版本, 应为 0. CD 代表结果码, 有以下几种取值:

-   90: 请求通过
-   91: 请求被拒或失败
-   92: 请求被拒, 由于 SOCKS 服务器无法连接到客户端的 identd
-   93: 由于客户端程序与 identd 报告的用户 ID 不匹配

注意, 请求通过时, DSTPORT 和 DSTIP 字段是有意义的. 这种情况下, SOCKS 服务器获得一个 socket 用以等待传入连接, 并将该 socket 的端口号和 IP 地址分别填入 DSTPORT 和 DSTIP 字段发送给客户端. 若回复中的 DSTIP 字段为 0 (常量 INADDR_ANY 的值), 则客户端将其替换为它所连接的 SOCKS 服务器的 IP 地址 (当且仅当 SOCKS 服务器不是多宿主主机). 在典型场景中, 这两这个值来自 getsockname() 操作调用的结果. 应用协议必须提供一种方法使得这两个信息可以由客户端发送至应用服务器, 以便它能够启动连接, 该连接连至 SOCKS 服务器而不是通常情况下直接连到应用服务器.

当来自应用服务器的预期连接建立起来时, SOCKS 服务器向客户端发送第二个回复包. SOCKS 服务器将源主机 IP 地址与客户端 BIND 请求中的 DSTIP 字段值进行比较, 若不匹配, 第二个回复包的 CD 字段置为 91, SOCKS 服务器同时关闭二者的连接. 若匹配, 第二个回复包中的 CD 字段置为 90, SOCKS 服务器立刻准备为两个连接上的数据做中继服务. 此后, 客户端在与 SOCKS 服务器的连接上进行 I/O 操作, 就如同它已直接连接到应用服务器.

对于 CONNECT 和 BIND 操作, 服务器都将为其与应用服务器的连接建立设置一个时间限制 (当前 CSTC 实现中为 2 分钟), 若超时连接仍未建立, 服务器放弃并断开与客户端的连接.
