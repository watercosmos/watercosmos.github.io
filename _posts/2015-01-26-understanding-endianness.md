---
title: 关于剥鸡蛋的圣战&#58; 理解字节序 (Endianness)
---



如果你和我一样, 对于网络编程中随处可见的 htons, htonl 等函数不明所以, 又或者遇到过 C 语言位字段的赋值问题, 或许你也需要深入了解一下字节序问题.


1\. 词源
--------

"endianness" 一词来源于小说 <格列佛游记>. 小说中，小人国国王发布敕令, 要求子民吃水煮蛋时必须从小的一端 (Little-End) 剥开, 由此引发 6 次叛乱, 11000 人死于坚持从大的一端 (Big-End) 剥开. 这个讽刺当时英法冲突的故事被 Danny Cohen 引用在 "On Holy Wars and a Plea for Peace" 一文中, 用以描述字节序之争, 后被广泛接受.


2\. 概念
--------

字节序是指计算机中跨越多字节的程序对象的存储规则. 计算机内存中, 每一个字节 (8-bit) 都有一个地址, 字节序规定一个多字节对象在一段连续内存地址中的存储顺序, 而存储顺序决定了数据的解析方式. 字节序主要分为两种: 大端序和小端序. 不同处理器采用的字节序不同.


3\. 大端序 (big-endian)
-----------------------

数据的最高位存储在最低内存地址处, 以 32-bit int 类型值 0x0A0B0C0D 在内存中的存放方式为例:

        地址增长方向 ->
    ---+------+------+------+------+---
       | 0x0A | 0x0B | 0x0C | 0x0D |
    ---+------+------+------+------+---

这类似于十六进制字节从左到右的阅读顺序.

Motorola 68k, IBM POWER, Atmel AVR32 等系列处理器使用大端序格式.


4\. 小端序 (little-endian)
--------------------------

数据的最低位存储在最低内存地址处, 同样以 0x0A0B0C0D 为例:

        地址增长方向 ->
    ---+------+------+------+------+---
       | 0x0D | 0x0C | 0x0B | 0x0A |
    ---+------+------+------+------+---

Intel x86 和 x86-64, 8051, Atmel AVR, Z80 等处理器架构使用小端序格式. 


5\. 对比
--------

![big-endian](/assets/big-endian.svg "big-endian")
![little-endian](/assets/little-endian.svg "little-endian")

大端序: 进行数值比较与近似值计算时, 如正负判断, 只需要从地址最低位的符号位开始读取, 通常读取高位数值即可, 而不必读取完整取值.

小端序: 同一数值以不同精度读取时, 无需改变数据的内存地址, 如 int, short, char 类型转化.

二者没有孰优孰劣, 然而由来已久, 均势已成, 争论的声音似乎也很小.


6\. 网络字节序 (network byte order)
-----------------------------------

互联网协议规定使用大端序作为网络字节序, BSD socket API 定义了一组转换函数, 用于 16-bit 和 32-bit 整数在本机字节序和网络字节序之间的转换.

-   htons (host-to-network-short)
-   htonl (host-to-network-long)
-   ntohs (network-to-host-short)
-   ntohl (network-to-host-long)

另外, 当我们讨论字节序时, 都是指多字节对象的存储顺序问题, 而不关心单字节内比特 (bit) 的存储顺序 (位序), 后者涉及的是硬件层面, 对于开发人员是透明的.

比特在传输媒质中的传输顺序通常类似于小端序, 即低位优先, 如 RS-232 和 Ethernet.

在计算机网络中, 比特传输顺序在 OSI 模型中数据链路层的底端被指定.


7\. 所以
--------

以上解释了为什么 Socket 编程时, 地址和端口号需要使用 htons 和 htonl 函数转换为网络字节序. 因为本地机器通常采用的是小端序 (Intel), 与网络字节序不匹配. 以下是一个简单的测试程序用于判断机器的字节序:

    int isBigEndian()
    {
        int  a = 0xABCD;
        char b = * (char *) &a;
    
        if (b == 0xAB)
            return 1;
        else
            return 0;
    }

给 C 语言位字段赋值原理类似, 例如:

    struct test {
        unsigned char a: 2;
        unsigned char b: 2;
        unsigned char c: 4;
    } dst;

    unsigned char src = 0x36;

    memcpy(&dst, &src, 1);

src 二进制值为 0b00110110, 以类似小端序的方式赋值 (不是基于字节, 而是位域), 结果 dst.a 为最低位 0b10, dst.b 为 0b01, dst.c 为高位的 0b0011. 如下:

        <- 地址增长方向
    +----+----+----+----+
    | 00   11 | 01 | 10 |
    +----+----+----+----+
    |    c    | b  | a  |
    +----+----+----+----+


8\. 谁是异端
------------

以我对计算机硬件有限的了解 (不了解), 只能大致从维基得到了这样一个故事: 在第一个程序员在山洞石壁上刻下第一行 "hello, world" 后不久, 英特尔着手为一款名为 Datapoint 2200 的上古神器开发处理器, 尽管 Datapoint 最初的设计要求是采用大端序, 然而为节省晶体管, 接受了英特尔将设计改为小端序的请求. 此后, 字节并行计算被采用 (8 位处理器 8008 出现?), 英特尔依然保留了小端序设计, 作为对 Datapoint 的承诺, 即兼容过去的位串行处理器. 然而讽刺的是, 由于英特尔最终没能及时发布 Intel 8008 , Datapoint 使用了一款 MSI 的处理器作为替代. 因此, 英特尔处理器此后的小端序设计实际上从未起到任何必要性作用.


9\. 引用
--------

[1]: 维基百科 <http://en.wikipedia.org/wiki/Endianness>
